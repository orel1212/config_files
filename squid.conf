#
# Recommended minimum configuration:
#

# Example rule allowing access from your local networks.
# Adapt to list your (internal) IP networks from where browsing
# should be allowed
acl localnet src 10.0.0.0/8     # RFC1918 possible internal network
acl localnet src 172.16.0.0/12  # RFC1918 possible internal network
acl localnet src 192.168.0.0/16 # RFC1918 possible internal network
acl localnet src fc00::/7       # RFC 4193 local private network range
acl localnet src fe80::/10      # RFC 4291 link-local (directly plugged) machines

acl SSL_ports port 443
acl Safe_ports port 80          # http
acl Safe_ports port 21          # ftp
acl Safe_ports port 443         # https
acl Safe_ports port 70          # gopher
acl Safe_ports port 210         # wais
acl Safe_ports port 1025-65535  # unregistered ports
acl Safe_ports port 280         # http-mgmt
acl Safe_ports port 488         # gss-http
acl Safe_ports port 591         # filemaker
acl Safe_ports port 777         # multiling http
acl CONNECT method CONNECT
acl YesAccess dstdomain "/usr/local/squid/etc/white_list"
#
# Recommended minimum Access Permission configuration:
#
# Deny requests to certain unsafe ports
http_access deny !Safe_ports

# Deny CONNECT to other than secure SSL ports
http_access deny CONNECT !SSL_ports

# Only allow cachemgr access from localhost
http_access allow localhost manager
http_access deny manager

# We strongly recommend the following be uncommented to protect innocent
# web applications running on the proxy server who think the only
# one who can access services on "localhost" is a local user
#http_access deny to_localhost

#
# INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS
#

# Example rule allowing access from your local networks.
# Adapt localnet in the ACL section to list your (internal) IP networks
# from where browsing should be allowed
http_access allow localnet
http_access allow localhost
visible_hostname = localhost
#http_access deny noAccess
# And finally deny all other access to this proxy
http_access allow YesAccess
http_access deny all

# Squid normally listens to port 3128
#http_port 3128
http_port 3128 ssl-bump generate-host-certificates=on dynamic_cert_mem_cache_size=6MB cert=/usr/local/squid/certs/squidCA.pem
sslcrtd_program /usr/local/squid/libexec/security_file_certgen -s /usr/local/squid/var/cache/squid_ssldb -M 4MB
#ssl_bump stare all
#ssl_bump bump all
acl step1 at_step SslBump1
acl step2 at_step SslBump2
acl step3 at_step SslBump3
acl nobumpSites ssl::server_name "/usr/local/squid/etc/sslsplice_list"
ssl_bump peek step1 all
ssl_bump peek step2 nobumpSites
ssl_bump splice step3 nobumpSites
ssl_bump stare step2
ssl_bump bump step3
# Uncomment and adjust the following to add a disk cache directory.
#cache_dir ufs /usr/local/squid/var/spool/squid 100 16 256

# Leave coredumps in the first cache dir
coredump_dir /usr/local/squid/var/cache/squid

#
# Add any of your own refresh_pattern entries above these.
#
refresh_pattern ^ftp:           1440    20%     10080
refresh_pattern ^gopher:        1440    0%      1440
refresh_pattern -i (/cgi-bin/|\?) 0     0%      0
refresh_pattern .               0       20%     4320

#NITAY'S WORK ON SSLBUMP - DONT TOUCH!

#sslcrtd_program /usr/lib64/squid/ssl_crtd -s /var/lib/squid/ssl_db -M 4MB
#acl step1 at_step SslBump1
#acl step2 at_step SslBump2
#acl step3 at_step SslBump3
#acl nobumpSites ssl::server_name "/etc/squid/nobumpSites.txt"
#sslcrtd_children 5

#part 1 - splicing only whats inside the nobumpSite file(using SNI), and bumping all the rest
#ssl_bump peek step1 all        # at step 1 we're peeking at client's TLS-request in order to find the SNI
#ssl_bump splice nobumpSites    # here we're splicing trusted connections to servers which names match our whitelist
#ssl_bump bump                  # and finally we're bumping all other SSL connections
#end part 1

#part 2 - same as part 1, but now peeking at CN and SAN of the server's certificate
#ssl_bump peek step1 all               # at step 1 we're peeking at client TLS-request in order to find the SNI
#ssl_bump peek step2 nobumpSites       # here we're peeking at server certificate
#ssl_bump splice step3 nobumpSites     # here we're splicing connections which match the whitelist
#ssl_bump bump                         # finally we're bumping all other SSL connections
#end part 2

#part 3 - So far, we've discussed actions like: peek, splice and bumb, but there is also stare.
#According to Squid documentation peeking at step 2 (peeking at server certificate) preserves the possibility of splicing the connection but usually precludes possibility of future bumping. For that reason peeking at server certificate (step 2) makes sense with nobumpSites acl. If you want Squid to stare at the server certificate before bumping the connection you must use stare option.
#ssl_bump peek step1 all               # at step 1 we're peeking at client TLS-request in order to find the "SNI"
#ssl_bump peek step2 nobumpSites       # here we're peeking at server certificate
#ssl_bump splice step3 nobumpSites     # here we're splicing connections which match the whitelist
#ssl_bump stare step2                  # here we're staring at server certificate
#ssl_bump bump step3                   # finally we're bumping all other SSL connections at step 3
#end part 3

#sslproxy_cert_error deny all

#END OF NITAY'S SSLBUMP



####icap thingy
#icap_enable on
#icap_send_client_ip on
#icap_send_client_username on
#icap_client_username_encode off
#icap_client_username_header X-Authenticated-User
#icap_preview_enable on
#icap_preview_size 0
#icap_service service_avi_req reqmod_precache icap://158.177.22.22:1344/squidclamav bypass=off
#adaptation_access service_avi_req allow all
#icap_service service_avi_resp respmod_precache icap://158.177.22.22:1344/squidclamav bypass=on
#adaptation_access service_avi_resp allow all
cache_effective_user squid
#cache_effective_user 1004530000
cache deny all
